% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossvalidation.R
\name{masc}
\alias{masc}
\title{Cross-validated Estimation of the Matching and Synthetic Control Estimator.}
\usage{
masc(data, tune_pars_list = list(m = NA, min_preperiods = NA, set_f =
  NA), nogurobi = FALSE, alloutput = FALSE)
}
\arguments{
\item{data}{A \code{list} containing three named elements: \describe{
\item{donors:}{A \eqn{TxN} matrix of outcome paths for untreated units, each column being a control unit.}
\item{treated:}{A \eqn{Tx1} matrix of outcome paths for the treated unit.}
\item{treatment:}{An integer. The period T' in which treatment begins (\eqn{T'<=T}).}
}

Note that currently this estimator is designed so that \code{donors} and \code{treated} should only contain
the time series values for a single outcome for each unit. It does not allow for including other covariates.}

\item{tune_pars_list}{A \code{list} containing 3 elements. You must specify the first, and you must specify
exctly one of the remaining two elements: \describe{
\item{m:}{ a vector of integers representing the set of candidate nearest neighbor estimators.}
\item{min_preperiods:}{an integer. The smallest number of estimation periods allowed in a fold used for cross-validation.}
\item{set_f:}{a \code{list} containing a single element, a vector of integers. Identifies the set of folds used
 for cross-validation. Each integer identifies a fold by the last time period used in estimation.}
}}

\item{nogurobi}{A logical value. If true, uses \link[LowRankQP]{LowRankQP} to solve the synthetic control estimator,
rather than \code{gurobi}.}

\item{alloutput}{A logical value. If true, output includes a list \code{all.results} containing
full set of output associated with each candidate nearest neighbor estimator.}
}
\value{
By default, returns a list containing five objects:
\describe{
\item{phi:}{selected value for the model averaging parameter (1 is pure matching, 0 pure synthetic control).}
\item{m:}{selected matching (nearest neighbor) estimator.}
\item{weights:}{The vector length N containing weights placed on each control unit.}
\item{pred.error:}{The vector of treatment effects implied by the masc counterfactual, for periods T' to T.}
\item{cv.error:}{The cross-validation error value returned by the optimal set of tuning parameter values.}
}
Additionally, returns the following object if \code{alloutput=TRUE}:
\describe{
\item{all.results:}{A list containing the five above output components for each candidate matching estimator. Values for
each candidate are appended as columns.}
}
}
\description{
Implements the matching and synthetic control (masc) estimator of Kellogg, Mogstad,
 Pouliot, and Torgovitsky (2019).
}
\details{
The \code{masc} estimator takes a convex combination of a
 nearest neighbor estimator and a synthetic control estimator. That combination
 is parametrized by a model averaging parameter which takes a value of 1 when
 the estimator is equivalent to a pure matching estimator, and 0 when it is equivalent
 to a pure synthetic control estimator.
  his includes selecting the nearest neighbor estimator and model
 averaging parameter by a rolling-origin cross-validation procedure. Computationally,
 we minimize the cross-validation criterion in two steps. First, for each candidate
 nearest neighbor estimator, we solve for the model averaging parameter using an analytic
 expression (see Equation 15 of the working paper). Then, we select the candidate nearest
 neighbor estimator which produces the smallest cross-validation criterion value.

This implementation by default uses \code{gurobi} interfaced with R to solve for the synthetic control estimator.
 Gurobi and its associated R package are available on the gurobi website:
 \url{https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html}

It is recommended to use this implementation of the \code{masc} estimator. However, the function may
 alternatively use an implementation based on \link[LowRankQP]{LowRankQP} for convenience.
}
\examples{
##First example: third introductory exercise of Kellogg et al. (2019),
## Figures 3 and 4:

data3 <- data.frame(t = 1:10, treated = 1:10,
control1 = c(15,12,14,22,21,28,29,30,29,31),
control2 = c(10,5,10,12,16,20,22,21,23,21),
control3 = c(-7,-11,-7,-3,-4,-9,-7,-3,-7,-11),
control4 = c(-15,-13,-14,-16,-15,-12,-13,-13,-14,-14))

#controls are above stored as differences from treated unit. Translating into levels:
data3$control1 <- data3$control1 + data3$treated
data3$control2 <- data3$control2 + data3$treated
data3$control3 <- data3$control3 + data3$treated
data3$control4 <- data3$control4 + data3$treated

#defining treatment period:
treatperiod <- 6

data<-list(treated = as.matrix(data3$treated),
           donors = as.matrix(data3[,-c(1,2)]),
            treatment=treatperiod)

result<-masc(data=data, tune_pars_list=list(m=1:3,
                                           min_preperiods=3,
                                           set_f=NA))

#an equivalent specification:
result<-masc(data=data, tune_pars_list=list(m=1:3,
                                           min_preperiods=NA,
                                           set_f=3:4))


#Weights selected, for controls 1 through 4 respectively:
print(round(result$weights,2))

##Second example: Terrorism in the Basque Region, from
##Abadie and Gardeazabal (2003).

#First, load the Synth package, which includes the dataset:
if (requireNamespace("Synth",quietly=TRUE) & requireNamespace("data.table",quietly=TRUE)){
library(Synth)
library(data.table)
data(basque)
basque<-as.data.table(basque)
basque <- basque[regionno!=1,]
basque[,regionname:= gsub(" (.*)","",regionname)]
#Grabbing region names:
names<- c(unique(basque[regionno==17,regionname]),unique(basque[regionno!=17,regionname]))
basque <- cbind(basque[regionno==17,gdpcap],
                                            t(reshape(basque[regionno!=17,.(regionno,year,gdpcap)],
                                             idvar='regionno', timevar='year',direction='wide')[,-"regionno",with=FALSE]))

data <- list(treated = as.matrix(basque[,1]),
             donors = as.matrix(basque[,-1]),
             treatment = 16)

result <- masc(data=data, tune_pars_list=list(m=1:10,
                                             min_preperiods=8,
                                             set_f=NA))
names(result$weights)<-names[-1]

#weights on control units:
print(round(result$weights,3))

#Treatment effects of terrorism on GDP per capita
#in thousands of 1986 US dollars, over 1970-1975:
#(first 6 years of treatment)
print(result$pred.error[1:6,])
}

}
\references{
Kellogg, M., M. Mogstad, G. Pouliot, and A. Torgovitsky. Combining Matching and Synthetic Control to Trade
 off Biases from Extrapolation and Interpolation. Working Paper, 2019.
}
\seealso{
Other masc functions: \code{\link{cv_masc}},
  \code{\link{solve_masc}}
}
\concept{masc functions}
